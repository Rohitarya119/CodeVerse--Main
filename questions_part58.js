module.exports = [
    { title: "Distinct Subsequences II", description: "Given a string s, return the number of distinct non-empty subsequences of s. Since the answer may be very large, return it modulo 10^9 + 7.", difficulty: "HARD", topics: ["String", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int distinctSubseqII(String s) { return 0; } }", javascript: "var distinctSubseqII = function(s) {};", python: "class Solution:\n    def distinctSubseqII(self, s: str) -> int:\n        pass", cpp: "class Solution { public: int distinctSubseqII(string s) { return 0; } };" }, function_name: "distinctSubseqII", examples: [] },
    { title: "Number of Music Playlists", description: "Your music player contains n different songs. You want to listen to goal (not necessarily different) songs during your trip. To avoid boredom, you will create a playlist so that: Every song is played at least once. A song can only be played again only if k other songs have been played. Given n, goal, and k, return the number of possible playlists. Since the answer can be very large, return it modulo 10^9 + 7.", difficulty: "HARD", topics: ["Math", "Dynamic Programming", "Combinatorics"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int numMusicPlaylists(int n, int goal, int k) { return 0; } }", javascript: "var numMusicPlaylists = function(n, goal, k) {};", python: "class Solution:\n    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\n        pass", cpp: "class Solution { public: int numMusicPlaylists(int n, int goal, int k) { return 0; } };" }, function_name: "numMusicPlaylists", examples: [] },
    { title: "Minimize Malibu", description: "In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial infected node list. Return the node that if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.", difficulty: "HARD", topics: ["DFS", "BFS", "Union Find", "Graph"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int minMalwareSpread(int[][] graph, int[] initial) { return 0; } }", javascript: "var minMalwareSpread = function(graph, initial) {};", python: "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        pass", cpp: "class Solution { public: int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) { return 0; } };" }, function_name: "minMalwareSpread", examples: [] },
    { title: "Three Equal Parts", description: "You are given an array arr which consists of only zeros and ones, divide the array into three non-empty parts such that all of these parts represent the same binary value. If it is possible, return any [i, j] with i + 1 < j, such that: arr[0], arr[1], ..., arr[i] is the first part, arr[i + 1], arr[i + 2], ..., arr[j - 1] is the second part, and arr[j], arr[j + 1], ..., arr[arr.length - 1] is the third part. All three parts have equal binary values. If it is not possible, return [-1, -1].", difficulty: "HARD", topics: ["Array", "Math"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int[] threeEqualParts(int[] arr) { return new int[]{}; } }", javascript: "var threeEqualParts = function(arr) {};", python: "class Solution:\n    def threeEqualParts(self, arr: List[int]) -> List[int]:\n        pass", cpp: "class Solution { public: vector<int> threeEqualParts(vector<int>& arr) { return {}; } };" }, function_name: "threeEqualParts", examples: [] },
    { title: "Cat and Mouse", description: "A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns. The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph. The mouse starts at node 1 and goes first, the cat starts at node 2 and goes second, and there is a hole at node 0. During each player's turn, they must travel along one edge of the graph that meets where they are. For example, if the Mouse is at node 1, it must travel to any node in graph[1]. Additionally, it is not allowed for the Cat to travel to the Hole (node 0).", difficulty: "HARD", topics: ["Math", "Dynamic Programming", "Graph", "Topological Sort", "Memoization", "Game Theory"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int catMouseGame(int[][] graph) { return 0; } }", javascript: "var catMouseGame = function(graph) {};", python: "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        pass", cpp: "class Solution { public: int catMouseGame(vector<vector<int>>& graph) { return 0; } };" }, function_name: "catMouseGame", examples: [] },
    { title: "Number of Atoms", description: "Given a string formula representing a chemical formula, return the count of each atom. The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name. One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.", difficulty: "HARD", topics: ["Hash Table", "String", "Stack", "Sorting"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public String countOfAtoms(String formula) { return \"\"; } }", javascript: "var countOfAtoms = function(formula) {};", python: "class Solution:\n    def countOfAtoms(self, formula: str) -> str:\n        pass", cpp: "class Solution { public: string countOfAtoms(string formula) { return \"\"; } };" }, function_name: "countOfAtoms", examples: [] },
    { title: "Reach a Number", description: "You are standing at position 0 on an infinite number line. There is a destination at position target. You can make some number of moves numMoves so that: On each move, you can either go left or right. During the ith move (starting from i == 1 to i == numMoves), you take i steps in the chosen direction. Given the integer target, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination.", difficulty: "MEDIUM", topics: ["Math", "Binary Search"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int reachNumber(int target) { return 0; } }", javascript: "var reachNumber = function(target) {};", python: "class Solution:\n    def reachNumber(self, target: int) -> int:\n        pass", cpp: "class Solution { public: int reachNumber(int target) { return 0; } };" }, function_name: "reachNumber", examples: [] },
    { title: "Partition to K Equal Sum Subsets", description: "Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.", difficulty: "MEDIUM", topics: ["Array", "Dynamic Programming", "Backtracking", "Bit Manipulation", "Memoization", "Bitmask"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean canPartitionKSubsets(int[] nums, int k) { return false; } }", javascript: "var canPartitionKSubsets = function(nums, k) {};", python: "class Solution:\n    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        pass", cpp: "class Solution { public: bool canPartitionKSubsets(vector<int>& nums, int k) { return false; } };" }, function_name: "canPartitionKSubsets", examples: [] },
    { title: "Shortest Path Visiting All Nodes", description: "You have an undirected, connected graph of n nodes labeled from 0 to n - 1. You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.", difficulty: "HARD", topics: ["Dynamic Programming", "BFS", "Graph", "Bit Masking"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int shortestPathLength(int[][] graph) { return 0; } }", javascript: "var shortestPathLength = function(graph) {};", python: "class Solution:\n    def shortestPathLength(self, graph: List[List[int]]) -> int:\n        pass", cpp: "class Solution { public: int shortestPathLength(vector<vector<int>>& graph) { return 0; } };" }, function_name: "shortestPathLength", examples: [] },
    { title: "Prime Palindrome", description: "Given an integer n, return the smallest prime palindrome greater than or equal to n. An integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number. For example, 2, 3, 5, 7, 11, and 13 are all primes. An integer is a palindrome if it reads the same from left to right as it does from right to left.", difficulty: "MEDIUM", topics: ["Math"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int primePalindrome(int n) { return 0; } }", javascript: "var primePalindrome = function(n) {};", python: "class Solution:\n    def primePalindrome(self, n: int) -> int:\n        pass", cpp: "class Solution { public: int primePalindrome(int n) { return 0; } };" }, function_name: "primePalindrome", examples: [] },
    { title: "Reconstruct Itinerary", description: "You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it. All of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.", difficulty: "HARD", topics: ["DFS", "Graph", "Eulerian Circuit"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<String> findItinerary(List<List<String>> tickets) { return new ArrayList<>(); } }", javascript: "var findItinerary = function(tickets) {};", python: "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        pass", cpp: "class Solution { public: vector<string> findItinerary(vector<vector<string>>& tickets) { return {}; } };" }, function_name: "findItinerary", examples: [] },
    { title: "Largest Component Size by Common Factor", description: "You are given an integer array of unique positive integers nums. Consider the following graph: There are nums.length nodes, labeled nums[0] to nums[nums.length - 1], There is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1. Return the size of the largest connected component in the graph.", difficulty: "HARD", topics: ["Array", "Math", "Union Find"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int largestComponentSize(int[] nums) { return 0; } }", javascript: "var largestComponentSize = function(nums) {};", python: "class Solution:\n    def largestComponentSize(self, nums: List[int]) -> int:\n        pass", cpp: "class Solution { public: int largestComponentSize(vector<int>& nums) { return 0; } };" }, function_name: "largestComponentSize", examples: [] },
    { title: "Least Operators to Express Number", description: "Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /). For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3. When writing such an expression, we adhere to the following conventions: The division operator (/) returns rational numbers. There are no parentheses placed anywhere. We use the usual order of operations: multiplication and division happen before addition and explanation. We are not allowed to use the unary negation operator. Return the least number of operators to express a given number target.", difficulty: "HARD", topics: ["Math", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int leastOpsExpressTarget(int x, int target) { return 0; } }", javascript: "var leastOpsExpressTarget = function(x, target) {};", python: "class Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        pass", cpp: "class Solution { public: int leastOpsExpressTarget(int x, int target) { return 0; } };" }, function_name: "leastOpsExpressTarget", examples: [] },
    { title: "Tallest Billboard", description: "You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height. You are given a collection of rods that can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6. Return the largest possible height of your billboard installation. If you cannot support the billboard, return 0.", difficulty: "HARD", topics: ["Array", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int tallestBillboard(int[] rods) { return 0; } }", javascript: "var tallestBillboard = function(rods) {};", python: "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        pass", cpp: "class Solution { public: int tallestBillboard(vector<int>& rods) { return 0; } };" }, function_name: "tallestBillboard", examples: [] },
    { title: "Binary Tree Cameras", description: "You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children. Return the minimum number of cameras needed to monitor all nodes of the tree.", difficulty: "HARD", topics: ["Dynamic Programming", "Tree", "DFS", "Binary Tree"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int minCameraCover(TreeNode root) { return 0; } }", javascript: "var minCameraCover = function(root) {};", python: "class Solution:\n    def minCameraCover(self, root: Optional[TreeNode]) -> int:\n        pass", cpp: "class Solution { public: int minCameraCover(TreeNode* root) { return 0; } };" }, function_name: "minCameraCover", examples: [] },
    { title: "Vertical Order Traversal of a Binary Tree", description: "Given the root of a binary tree, calculate the vertical order traversal of the binary tree. For each node at position (row, col), its left and right children will be at positions (row + 1, col - 1) and (row + 1, col + 1) respectively. The root of the tree is at (0, 0). The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.", difficulty: "HARD", topics: ["Hash Table", "Tree", "DFS", "BFS", "Binary Tree"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<List<Integer>> verticalTraversal(TreeNode root) { return new ArrayList<>(); } }", javascript: "var verticalTraversal = function(root) {};", python: "class Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        pass", cpp: "class Solution { public: vector<vector<int>> verticalTraversal(TreeNode* root) { return {}; } };" }, function_name: "verticalTraversal", examples: [] },
    { title: "Triples with Bitwise AND Equal To Zero", description: "Given an integer array nums, return the number of AND triples. An AND triple is a triple of indices (i, j, k) such that: 0 <= i < nums.length, 0 <= j < nums.length, 0 <= k < nums.length, and nums[i] & nums[j] & nums[k] == 0, where & represents the bitwise-AND operator.", difficulty: "HARD", topics: ["Array", "Hash Table", "Bit Manipulation"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int countTriplets(int[] nums) { return 0; } }", javascript: "var countTriplets = function(nums) {};", python: "class Solution:\n    def countTriplets(self, nums: List[int]) -> int:\n        pass", cpp: "class Solution { public: int countTriplets(vector<int>& nums) { return 0; } };" }, function_name: "countTriplets", examples: [] },
    { title: "Minimum Cost to Merge Stones", description: "There are n piles of stones arranged in a row. The ith pile has stones[i] stones. A move consists of merging exactly k consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these k piles. Return the minimum cost to merge all piles of stones into one pile. If it is impossible, return -1.", difficulty: "HARD", topics: ["Array", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int mergeStones(int[] stones, int k) { return 0; } }", javascript: "var mergeStones = function(stones, k) {};", python: "class Solution:\n    def mergeStones(self, stones: List[int], k: int) -> int:\n        pass", cpp: "class Solution { public: int mergeStones(vector<int>& stones, int k) { return 0; } };" }, function_name: "mergeStones", examples: [] },
    { title: "Number of Squareful Arrays", description: "Given an integer array nums, return the number of permutations of nums that are squareful. A permutation is squareful if for every pair of adjacent elements, their sum is a perfect square.", difficulty: "HARD", topics: ["Array", "Math", "Backtracking", "Bit Manipulation"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int numSquarefulPerms(int[] nums) { return 0; } }", javascript: "var numSquarefulPerms = function(nums) {};", python: "class Solution:\n    def numSquarefulPerms(self, nums: List[int]) -> int:\n        pass", cpp: "class Solution { public: int numSquarefulPerms(vector<int>& nums) { return 0; } };" }, function_name: "numSquarefulPerms", examples: [] },
    { title: "Stream of Characters", description: "Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings words.", difficulty: "HARD", topics: ["Array", "String", "Design", "Trie", "Data Stream"], constraints: [], hints: [], boilerplate_code: { java: "class StreamChecker { public StreamChecker(String[] words) {} public boolean query(char letter) { return false; } }", javascript: "var StreamChecker = function(words) {}; StreamChecker.prototype.query = function(letter) {};", python: "class StreamChecker:\n    def __init__(self, words: List[str]):\n        pass\n    def query(self, letter: str) -> bool:\n        pass", cpp: "class StreamChecker { public: StreamChecker(vector<string>& words) {} bool query(char letter) { return false; } };" }, function_name: "query", examples: [] },
    { title: "Longest Duplicate Substring", description: "Given a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap. Return any duplicated substring that has the longest possible length. If s does not have a duplicated substring, the answer is \"\".", difficulty: "HARD", topics: ["String", "Binary Search", "Sliding Window", "Rolling Hash", "Suffix Array"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public String longestDupSubstring(String s) { return \"\"; } }", javascript: "var longestDupSubstring = function(s) {};", python: "class Solution:\n    def longestDupSubstring(self, s: str) -> str:\n        pass", cpp: "class Solution { public: string longestDupSubstring(string s) { return \"\"; } };" }, function_name: "longestDupSubstring", examples: [] },
    { title: "Recover a Tree From Preorder Traversal", description: "We run a preorder depth-first search (DFS) on the root of a binary tree. At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node. If the depth of a node is D, the depth of its immediate child is D + 1. The depth of the root node is 0. If a node has only one child, that child is guaranteed to be the left child. Given the output traversal of this traversal, recover the tree and return its root.", difficulty: "HARD", topics: ["String", "Tree", "DFS", "Binary Tree"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public TreeNode recoverFromPreorder(String traversal) { return null; } }", javascript: "var recoverFromPreorder = function(traversal) {};", python: "class Solution:\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\n        pass", cpp: "class Solution { public: TreeNode* recoverFromPreorder(string traversal) { return nullptr; } };" }, function_name: "recoverFromPreorder", examples: [] },
    { title: "Last Stone Weight II", description: "You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights x and y with x <= y. The result of this smash is: If x == y, both stones are destroyed, and If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x. At the end of the game, there is at most one stone left. Return the smallest possible weight of the left stone. If there are no stones left, return 0.", difficulty: "MEDIUM", topics: ["Array", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int lastStoneWeightII(int[] stones) { return 0; } }", javascript: "var lastStoneWeightII = function(stones) {};", python: "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        pass", cpp: "class Solution { public: int lastStoneWeightII(vector<int>& stones) { return 0; } };" }, function_name: "lastStoneWeightII", examples: [] },
    { title: "Shortest Common Supersequence", description: "Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences. If there are multiple valid strings, return any of them. A string s is a subsequence of string t if deleting some number of characters from t (possibly 0) results in the string s.", difficulty: "HARD", topics: ["String", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public String shortestCommonSupersequence(String str1, String str2) { return \"\"; } }", javascript: "var shortestCommonSupersequence = function(str1, str2) {};", python: "class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        pass", cpp: "class Solution { public: string shortestCommonSupersequence(string str1, string str2) { return \"\"; } };" }, function_name: "shortestCommonSupersequence", examples: [] },
    { title: "Parsing A Boolean Expression", description: "A boolean expression is an expression that evaluates to either true or false. It can be in one of the following shapes: 't' that evaluates to true. 'f' that evaluates to false. '!(subExpr)' that evaluates to the logical NOT of the inner expression subExpr. '&(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical AND of the inner expressions subExpr1, subExpr2, ..., subExprn. '|(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical OR of the inner expressions subExpr1, subExpr2, ..., subExprn. Given a string expression that represents a boolean expression, return the evaluation of that expression.", difficulty: "HARD", topics: ["String", "Stack", "Recursion"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean parseBoolExpr(String expression) { return false; } }", javascript: "var parseBoolExpr = function(expression) {};", python: "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        pass", cpp: "class Solution { public: bool parseBoolExpr(string expression) { return false; } };" }, function_name: "parseBoolExpr", examples: [] },
    { title: "Critical Connections in a Network", description: "There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network. A critical connection is a connection that, if removed, will make some servers unable to reach some other server. Return all critical connections in the network in any order.", difficulty: "HARD", topics: ["DFS", "Graph", "Strongly Connected Component", "Biconnected Component"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) { return new ArrayList<>(); } }", javascript: "var criticalConnections = function(n, connections) {};", python: "class Solution:\n    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:\n        pass", cpp: "class Solution { public: vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) { return {}; } };" }, function_name: "criticalConnections", examples: [] },
    { title: "Remove Invalid Parentheses", description: "Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid. Return all the possible results. You may return the answer in any order.", difficulty: "HARD", topics: ["String", "Backtracking", "BFS"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<String> removeInvalidParentheses(String s) { return new ArrayList<>(); } }", javascript: "var removeInvalidParentheses = function(s) {};", python: "class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        pass", cpp: "class Solution { public: vector<string> removeInvalidParentheses(string s) { return {}; } };" }, function_name: "removeInvalidParentheses", examples: [] },
    { title: "First Missing Positive", description: "Given an unsorted integer array nums, return the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space.", difficulty: "HARD", topics: ["Array", "Hash Table"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int firstMissingPositive(int[] nums) { return 0; } }", javascript: "var firstMissingPositive = function(nums) {};", python: "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        pass", cpp: "class Solution { public: int firstMissingPositive(vector<int>& nums) { return 0; } };" }, function_name: "firstMissingPositive", examples: [] },
    { title: "Trapping Rain Water", description: "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.", difficulty: "HARD", topics: ["Array", "Two Pointers", "Dynamic Programming", "Stack", "Monotonic Stack"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int trap(int[] height) { return 0; } }", javascript: "var trap = function(height) {};", python: "class Solution:\n    def trap(self, height: List[int]) -> int:\n        pass", cpp: "class Solution { public: int trap(vector<int>& height) { return 0; } };" }, function_name: "trap", examples: [] },
    { title: "Wildcard Matching", description: "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial).", difficulty: "HARD", topics: ["String", "Dynamic Programming", "Greedy", "Recursion"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean isMatch(String s, String p) { return false; } }", javascript: "var isMatch = function(s, p) {};", python: "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        pass", cpp: "class Solution { public: bool isMatch(string s, string p) { return false; } };" }, function_name: "isMatch", examples: [] }
];
