module.exports = [
    { title: "Self Crossing", description: "You are given an array of integers distance. You start at point (0,0) on an X-Y plane and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise. Return true if your path crosses itself, and false if it does not.", difficulty: "HARD", topics: ["Array", "Math", "Geometry"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean isSelfCrossing(int[] distance) { return false; } }", javascript: "var isSelfCrossing = function(distance) {};", python: "class Solution:\n    def isSelfCrossing(self, distance: List[int]) -> bool:\n        pass", cpp: "class Solution { public: bool isSelfCrossing(vector<int>& distance) { return false; } };" }, function_name: "isSelfCrossing", examples: [] },
    { title: "Patching Array", description: "Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.", difficulty: "HARD", topics: ["Array", "Greedy"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int minPatches(int[] nums, int n) { return 0; } }", javascript: "var minPatches = function(nums, n) {};", python: "class Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        pass", cpp: "class Solution { public: int minPatches(vector<int>& nums, int n) { return 0; } };" }, function_name: "minPatches", examples: [] },
    { title: "Create Sorted Array through Instructions", description: "Given an integer array instructions, you are asked to create a sorted array from the elements in instructions. You start with an empty container nums. For each element from left to right in instructions, insert it into nums. The cost of each insertion is the minimum of the number of elements currently in nums that are strictly less than instructions[i] or the number of elements currently in nums that are strictly greater than instructions[i]. Return the total cost modulo 10^9 + 7.", difficulty: "HARD", topics: ["Array", "Binary Search", "Divide and Conquer", "Binary Indexed Tree", "Segment Tree", "Merge Sort", "Ordered Set"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int createSortedArray(int[] instructions) { return 0; } }", javascript: "var createSortedArray = function(instructions) {};", python: "class Solution:\n    def createSortedArray(self, instructions: List[int]) -> int:\n        pass", cpp: "class Solution { public: int createSortedArray(vector<int>& instructions) { return 0; } };" }, function_name: "createSortedArray", examples: [] },
    { title: "Maximize Grid Happiness", description: "You are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. There are introvertsCount introverts and extrovertsCount extroverts. You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid. Happiness rules: Introverts start with 120 happiness and lose 30 happiness for each neighbor. Extroverts start with 40 happiness and gain 20 happiness for each neighbor. Neighbors are directly adjacent cells.", difficulty: "HARD", topics: ["Dynamic Programming", "Bit Masking", "Matrix", "Memoization"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) { return 0; } }", javascript: "var getMaxGridHappiness = function(m, n, introvertsCount, extrovertsCount) {};", python: "class Solution:\n    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:\n        pass", cpp: "class Solution { public: int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) { return 0; } };" }, function_name: "getMaxGridHappiness", examples: [] },
    { title: "Rank Transform of a Matrix", description: "Given an m x n matrix, return a new matrix answer where answer[row][col] is the rank of matrix[row][col]. The rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules: The rank is an integer starting from 1. If two elements p and q are in the same row or column, then: If p < q then rank(p) < rank(q). If p == q then rank(p) == rank(q). If p > q then rank(p) > rank(q). The rank should be as small as possible.", difficulty: "HARD", topics: ["Array", "Greedy", "Union Find", "Graph", "Topological Sort", "Matrix"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int[][] matrixRankTransform(int[][] matrix) { return new int[][]{}; } }", javascript: "var matrixRankTransform = function(matrix) {};", python: "class Solution:\n    def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n        pass", cpp: "class Solution { public: vector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) { return {}; } };" }, function_name: "matrixRankTransform", examples: [] },
    { title: "Maximum Height by Stacking Cuboids", description: "Given n cuboids where the dimensions of the ith cuboid is cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose a subset of cuboids and place them on each other. You can place cuboid i on cuboid j if widthi <= widthj and lengthi <= lengthj and heighti <= heightj. You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid. Return the maximum height of the stacked cuboids.", difficulty: "HARD", topics: ["Array", "Dynamic Programming", "Sorting"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int maxHeight(int[][] cuboids) { return 0; } }", javascript: "var maxHeight = function(cuboids) {};", python: "class Solution:\n    def maxHeight(self, cuboids: List[List[int]]) -> int:\n        pass", cpp: "class Solution { public: int maxHeight(vector<vector<int>>& cuboids) { return 0; } };" }, function_name: "maxHeight", examples: [] },
    { title: "Find Minimum in Rotated Sorted Array II", description: "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become: [4,5,6,7,0,1,4] if it was rotated 4 times. [0,1,4,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array.", difficulty: "HARD", topics: ["Array", "Binary Search"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int findMin(int[] nums) { return 0; } }", javascript: "var findMin = function(nums) {};", python: "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        pass", cpp: "class Solution { public: int findMin(vector<int>& nums) { return 0; } };" }, function_name: "findMin", examples: [] },
    { title: "Search in Rotated Sorted Array II", description: "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values). Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4]. Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.", difficulty: "MEDIUM", topics: ["Array", "Binary Search"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean search(int[] nums, int target) { return false; } }", javascript: "var search = function(nums, target) {};", python: "class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        pass", cpp: "class Solution { public: bool search(vector<int>& nums, int target) { return false; } };" }, function_name: "search", examples: [] },
    { title: "Contains Duplicate III", description: "You are given an integer array nums and two integers indexDiff and valueDiff. Find a pair of indices (i, j) such that: i != j, abs(i - j) <= indexDiff, and abs(nums[i] - nums[j]) <= valueDiff. Return true if such pair exists or false otherwise.", difficulty: "HARD", topics: ["Array", "Bucket Sort", "Ordered Set", "Sliding Window"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) { return false; } }", javascript: "var containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {};", python: "class Solution:\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\n        pass", cpp: "class Solution { public: bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) { return false; } };" }, function_name: "containsNearbyAlmostDuplicate", examples: [] },
    { title: "Word Search", description: "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.", difficulty: "MEDIUM", topics: ["Array", "Backtracking", "Matrix"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean exist(char[][] board, String word) { return false; } }", javascript: "var exist = function(board, word) {};", python: "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        pass", cpp: "class Solution { public: bool exist(vector<vector<char>>& board, string word) { return false; } };" }, function_name: "exist", examples: [] },
    { title: "Combinations", description: "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n]. You may return the answer in any order.", difficulty: "MEDIUM", topics: ["Backtracking"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<List<Integer>> combine(int n, int k) { return new ArrayList<>(); } }", javascript: "var combine = function(n, k) {};", python: "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        pass", cpp: "class Solution { public: vector<vector<int>> combine(int n, int k) { return {}; } };" }, function_name: "combine", examples: [] },
    { title: "Subsets", description: "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.", difficulty: "MEDIUM", topics: ["Array", "Backtracking", "Bit Manipulation"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<List<Integer>> subsets(int[] nums) { return new ArrayList<>(); } }", javascript: "var subsets = function(nums) {};", python: "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        pass", cpp: "class Solution { public: vector<vector<int>> subsets(vector<int>& nums) { return {}; } };" }, function_name: "subsets", examples: [] },
    { title: "Permutations", description: "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.", difficulty: "MEDIUM", topics: ["Array", "Backtracking"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<List<Integer>> permute(int[] nums) { return new ArrayList<>(); } }", javascript: "var permute = function(nums) {};", python: "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        pass", cpp: "class Solution { public: vector<vector<int>> permute(vector<int>& nums) { return {}; } };" }, function_name: "permute", examples: [] },
    { title: "Permutations II", description: "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.", difficulty: "MEDIUM", topics: ["Array", "Backtracking"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<List<Integer>> permuteUnique(int[] nums) { return new ArrayList<>(); } }", javascript: "var permuteUnique = function(nums) {};", python: "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        pass", cpp: "class Solution { public: vector<vector<int>> permuteUnique(vector<int>& nums) { return {}; } };" }, function_name: "permuteUnique", examples: [] },
    { title: "Combination Sum", description: "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.", difficulty: "MEDIUM", topics: ["Array", "Backtracking"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<List<Integer>> combinationSum(int[] candidates, int target) { return new ArrayList<>(); } }", javascript: "var combinationSum = function(candidates, target) {};", python: "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        pass", cpp: "class Solution { public: vector<vector<int>> combinationSum(vector<int>& candidates, int target) { return {}; } };" }, function_name: "combinationSum", examples: [] },
    { title: "Combination Sum II", description: "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations.", difficulty: "MEDIUM", topics: ["Array", "Backtracking"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<List<Integer>> combinationSum2(int[] candidates, int target) { return new ArrayList<>(); } }", javascript: "var combinationSum2 = function(candidates, target) {};", python: "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        pass", cpp: "class Solution { public: vector<vector<int>> combinationSum2(vector<int>& candidates, int target) { return {}; } };" }, function_name: "combinationSum2", examples: [] },
    { title: "Combination Sum III", description: "Find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.", difficulty: "MEDIUM", topics: ["Array", "Backtracking"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<List<Integer>> combinationSum3(int k, int n) { return new ArrayList<>(); } }", javascript: "var combinationSum3 = function(k, n) {};", python: "class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        pass", cpp: "class Solution { public: vector<vector<int>> combinationSum3(int k, int n) { return {}; } };" }, function_name: "combinationSum3", examples: [] },
    { title: "Letter Combinations of a Phone Number", description: "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.", difficulty: "MEDIUM", topics: ["Hash Table", "String", "Backtracking"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<String> letterCombinations(String digits) { return new ArrayList<>(); } }", javascript: "var letterCombinations = function(digits) {};", python: "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        pass", cpp: "class Solution { public: vector<string> letterCombinations(string digits) { return {}; } };" }, function_name: "letterCombinations", examples: [] },
    { title: "Generate Parentheses", description: "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.", difficulty: "MEDIUM", topics: ["String", "Dynamic Programming", "Backtracking"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<String> generateParenthesis(int n) { return new ArrayList<>(); } }", javascript: "var generateParenthesis = function(n) {};", python: "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        pass", cpp: "class Solution { public: vector<string> generateParenthesis(int n) { return {}; } };" }, function_name: "generateParenthesis", examples: [] },
    { title: "Target Sum", description: "You are given an integer array nums and an integer target. You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers. For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \"+2-1\". Return the number of different expressions that you can build, which evaluates to target.", difficulty: "MEDIUM", topics: ["Array", "Dynamic Programming", "Backtracking"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int findTargetSumWays(int[] nums, int target) { return 0; } }", javascript: "var findTargetSumWays = function(nums, target) {};", python: "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        pass", cpp: "class Solution { public: int findTargetSumWays(vector<int>& nums, int target) { return 0; } };" }, function_name: "findTargetSumWays", examples: [] },
    { title: "Partition Equal Subset Sum", description: "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.", difficulty: "MEDIUM", topics: ["Array", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean canPartition(int[] nums) { return false; } }", javascript: "var canPartition = function(nums) {};", python: "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        pass", cpp: "class Solution { public: bool canPartition(vector<int>& nums) { return false; } };" }, function_name: "canPartition", examples: [] },
    { title: "Ones and Zeroes", description: "You are given an array of binary strings strs and two integers m and n. Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset. A set x is a subset of a set y if all elements of x are also elements of y.", difficulty: "MEDIUM", topics: ["Array", "String", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int findMaxForm(String[] strs, int m, int n) { return 0; } }", javascript: "var findMaxForm = function(strs, m, n) {};", python: "class Solution:\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n        pass", cpp: "class Solution { public: int findMaxForm(vector<string>& strs, int m, int n) { return 0; } };" }, function_name: "findMaxForm", examples: [] },
    { title: "Coin Change II", description: "You are given an integer array of coins representing coins of different denominations and an integer amount representing a total amount of money. Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0. You may assume that you have an infinite number of each kind of coin. The answer is guaranteed to fit into a signed 32-bit integer.", difficulty: "MEDIUM", topics: ["Array", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int change(int amount, int[] coins) { return 0; } }", javascript: "var change = function(amount, coins) {};", python: "class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        pass", cpp: "class Solution { public: int change(int amount, vector<int>& coins) { return 0; } };" }, function_name: "change", examples: [] },
    { title: "Unique Paths", description: "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.", difficulty: "MEDIUM", topics: ["Math", "Dynamic Programming", "Combinatorics"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int uniquePaths(int m, int n) { return 0; } }", javascript: "var uniquePaths = function(m, n) {};", python: "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        pass", cpp: "class Solution { public: int uniquePaths(int m, int n) { return 0; } };" }, function_name: "uniquePaths", examples: [] },
    { title: "Unique Paths II", description: "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. An obstacle and space are marked as 1 and 0 respectively in the grid. A path that the robot takes cannot include any square that is an obstacle. Return the number of possible unique paths that the robot can take to reach the bottom-right corner.", difficulty: "MEDIUM", topics: ["Array", "Dynamic Programming", "Matrix"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { return 0; } }", javascript: "var uniquePathsWithObstacles = function(obstacleGrid) {};", python: "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        pass", cpp: "class Solution { public: int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) { return 0; } };" }, function_name: "uniquePathsWithObstacles", examples: [] },
    { title: "Minimum Path Sum", description: "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time.", difficulty: "MEDIUM", topics: ["Array", "Dynamic Programming", "Matrix"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int minPathSum(int[][] grid) { return 0; } }", javascript: "var minPathSum = function(grid) {};", python: "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        pass", cpp: "class Solution { public: int minPathSum(vector<vector<int>>& grid) { return 0; } };" }, function_name: "minPathSum", examples: [] },
    { title: "Climbing Stairs", description: "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?", difficulty: "EASY", topics: ["Math", "Dynamic Programming", "Memoization"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int climbStairs(int n) { return 0; } }", javascript: "var climbStairs = function(n) {};", python: "class Solution:\n    def climbStairs(self, n: int) -> int:\n        pass", cpp: "class Solution { public: int climbStairs(int n) { return 0; } };" }, function_name: "climbStairs", examples: [] },
    { title: "Fibonacci Number", description: "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1, F(n) = F(n - 1) + F(n - 2), for n > 1. Given n, calculate F(n).", difficulty: "EASY", topics: ["Math", "Dynamic Programming", "Recursion", "Memoization"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int fib(int n) { return 0; } }", javascript: "var fib = function(n) {};", python: "class Solution:\n    def fib(self, n: int) -> int:\n        pass", cpp: "class Solution { public: int fib(int n) { return 0; } };" }, function_name: "fib", examples: [] },
    { title: "N-th Tribonacci Number", description: "The Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0. Given n, return the value of Tn.", difficulty: "EASY", topics: ["Math", "Dynamic Programming", "Memoization"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int tribonacci(int n) { return 0; } }", javascript: "var tribonacci = function(n) {};", python: "class Solution:\n    def tribonacci(self, n: int) -> int:\n        pass", cpp: "class Solution { public: int tribonacci(int n) { return 0; } };" }, function_name: "tribonacci", examples: [] },
    { title: "Pascals Triangle", description: "Given an integer numRows, return the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:", difficulty: "EASY", topics: ["Array", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<List<Integer>> generate(int numRows) { return new ArrayList<>(); } }", javascript: "var generate = function(numRows) {};", python: "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        pass", cpp: "class Solution { public: vector<vector<int>> generate(int numRows) { return {}; } };" }, function_name: "generate", examples: [] }
];
