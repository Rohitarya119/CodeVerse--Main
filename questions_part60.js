module.exports = [
    { title: "Kth Smallest Instructions", description: "Bob is standing at cell (0, 0), and he wants to reach destination: (row, column). He can only travel right and down. You are going to help Bob to get to destination (row, column). However, Bob doesn't want to receive instructions like \"RRDD\". He wants the kth lexicographically smallest instructions that will lead him to destination (row, column). k is 1-indexed. Given an integer array destination and an integer k, return the kth lexicographically smallest instructions that will take Bob to destination.", difficulty: "HARD", topics: ["Array", "Math", "Dynamic Programming", "Combinatorics"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public String kthSmallestPath(int[] destination, int k) { return \"\"; } }", javascript: "var kthSmallestPath = function(destination, k) {};", python: "class Solution:\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\n        pass", cpp: "class Solution { public: string kthSmallestPath(vector<int>& destination, int k) { return \"\"; } };" }, function_name: "kthSmallestPath", examples: [] },
    { title: "Minimum Initial Energy to Finish Tasks", description: "You are given an array tasks where tasks[i] = [actuali, minimumi]: actuali is the actual amount of energy you spend to finish the ith task. minimumi is the minimum amount of energy you require to begin the ith task. For example, if the task is [10, 12] and your current energy is 11, you cannot start this task. However, if your current energy is 13, you can complete this task, and your energy becomes 13 - 10 = 3. Return the minimum initial amount of energy you will need to finish all the tasks.", difficulty: "HARD", topics: ["Array", "Greedy", "Sorting"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int minimumEffort(int[][] tasks) { return 0; } }", javascript: "var minimumEffort = function(tasks) {};", python: "class Solution:\n    def minimumEffort(self, tasks: List[List[int]]) -> int:\n        pass", cpp: "class Solution { public: int minimumEffort(vector<vector<int>>& tasks) { return 0; } };" }, function_name: "minimumEffort", examples: [] },
    { title: "Check If Two Expression Trees are Equivalent", description: "A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (variables), and internal nodes (nodes with 2 children) correspond to the operators. In this problem, we only consider the '+' operator (i.e. addition). You are given the roots of two binary expression trees, root1 and root2. Return true if the two binary expression trees are equivalent. Otherwise, return false.", difficulty: "MEDIUM", topics: ["Tree", "DFS", "Brainteaser"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean checkEquivalence(Node root1, Node root2) { return false; } }", javascript: "var checkEquivalence = function(root1, root2) {};", python: "class Solution:\n    def checkEquivalence(self, root1: 'Node', root2: 'Node') -> bool:\n        pass", cpp: "class Solution { public: bool checkEquivalence(Node* root1, Node* root2) { return false; } };" }, function_name: "checkEquivalence", examples: [] },
    { title: "Minimize Deviation in Array", description: "You are given an array nums of n positive integers. You can perform two types of operations on any element of the array any number of times: If the element is even, divide it by 2. If the element is odd, multiply it by 2. Return the minimum deviation the array can have after performing some number of operations.", difficulty: "HARD", topics: ["Array", "Greedy", "Heap", "Ordered Set"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int minimumDeviation(int[] nums) { return 0; } }", javascript: "var minimumDeviation = function(nums) {};", python: "class Solution:\n    def minimumDeviation(self, nums: List[int]) -> int:\n        pass", cpp: "class Solution { public: int minimumDeviation(vector<int>& nums) { return 0; } };" }, function_name: "minimumDeviation", examples: [] },
    { title: "Delivering Boxes from Storage to Ports", description: "You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a limit on the number of boxes and the total weight that it can carry. Given an array of boxes, portsCount, maxBoxes, and maxWeight, return the minimum number of trips to deliver all boxes to their respective ports.", difficulty: "HARD", topics: ["Array", "Dynamic Programming", "Segment Tree", "Queue", "Monotonic Queue"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) { return 0; } }", javascript: "var boxDelivering = function(boxes, portsCount, maxBoxes, maxWeight) {};", python: "class Solution:\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n        pass", cpp: "class Solution { public: int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) { return 0; } };" }, function_name: "boxDelivering", examples: [] },
    { title: "Maximum Number of Non-Overlapping Substrings", description: "Given a string s of lowercase letters, you need to find the maximum number of non-empty substrings of s that meet the following conditions: The substrings do not overlap, meaning for any two substrings s[i..j] and s[x..y], either j < x or i > y is true. A substring that contains a certain character c must also contain all occurrences of c. Find the maximum number of such substrings.", difficulty: "HARD", topics: ["String", "Greedy"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<String> maxNumOfSubstrings(String s) { return new ArrayList<>(); } }", javascript: "var maxNumOfSubstrings = function(s) {};", python: "class Solution:\n    def maxNumOfSubstrings(self, s: str) -> List[str]:\n        pass", cpp: "class Solution { public: vector<string> maxNumOfSubstrings(string s) { return {}; } };" }, function_name: "maxNumOfSubstrings", examples: [] },
    { title: "Minimum Operations to Make a Subsequence", description: "You are given an array target that consists of distinct integers and another integer array arr that can have duplicates. In one operation, you can insert any integer at any position in arr. For example, if arr = [1,4,1,2], you can add 3 in the middle and make it [1,4,3,1,2]. Note that you can perform the operation at any number of times. Return the minimum number of operations needed to make target a subsequence of arr.", difficulty: "HARD", topics: ["Array", "Hash Table", "Binary Search", "Greedy"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int minOperations(int[] target, int[] arr) { return 0; } }", javascript: "var minOperations = function(target, arr) {};", python: "class Solution:\n    def minOperations(self, target: List[int], arr: List[int]) -> int:\n        pass", cpp: "class Solution { public: int minOperations(vector<int>& target, vector<int>& arr) { return 0; } };" }, function_name: "minOperations", examples: [] },
    { title: "Number of Restricted Paths From First to Last Node", description: "There is an undirected weighted connected graph. You are given a positive integer n which denotes that the graph has n nodes labeled from 1 to n, and an array edges where each edges[i] = [ui, vi, weighti] denotes that there is an edge between nodes ui and vi with weight equal to weighti. A path from node start to node end is a sequence of nodes [z0, z1, ..., zk] such that z0 = start and zk = end and there is an edge between zi and zi+1 where 0 <= i <= k-1. The distance of a path is the sum of the weights on the edges of the path. Let distanceToLastNode(x) denote the shortest distance of a path between node x and node n. A restricted path is a path that also satisfies that distanceToLastNode(zi) > distanceToLastNode(zi+1) where 0 <= i <= k-1. Return the number of restricted paths from node 1 to node n. Since that number may be too large, return it modulo 10^9 + 7.", difficulty: "MEDIUM", topics: ["Dynamic Programming", "Graph", "Topological Sort", "Shortest Path"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int countRestrictedPaths(int n, int[][] edges) { return 0; } }", javascript: "var countRestrictedPaths = function(n, edges) {};", python: "class Solution:\n    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n        pass", cpp: "class Solution { public: int countRestrictedPaths(int n, vector<vector<int>>& edges) { return 0; } };" }, function_name: "countRestrictedPaths", examples: [] },
    { title: "Maximum Score from Performing Multiplication Operations", description: "You are given two integer arrays nums and multipliers of size n and m respectively, where n >= m. The arrays are 1-indexed. You begin with a score of 0. You want to perform exactly m operations. On the ith operation (1-indexed), you will: Choose one integer x from either the start or the end of the array nums. Add multipliers[i] * x to your score. Remove x from the array nums. Return the maximum score after performing m operations.", difficulty: "HARD", topics: ["Array", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int maximumScore(int[] nums, int[] multipliers) { return 0; } }", javascript: "var maximumScore = function(nums, multipliers) {};", python: "class Solution:\n    def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:\n        pass", cpp: "class Solution { public: int maximumScore(vector<int>& nums, vector<int>& multipliers) { return 0; } };" }, function_name: "maximumScore", examples: [] },
    { title: "Longest Valid Parentheses", description: "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.", difficulty: "HARD", topics: ["String", "Dynamic Programming", "Stack"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int longestValidParentheses(String s) { return 0; } }", javascript: "var longestValidParentheses = function(s) {};", python: "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        pass", cpp: "class Solution { public: int longestValidParentheses(string s) { return 0; } };" }, function_name: "longestValidParentheses", examples: [] },
    { title: "Candy", description: "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children.", difficulty: "HARD", topics: ["Array", "Greedy"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int candy(int[] ratings) { return 0; } }", javascript: "var candy = function(ratings) {};", python: "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        pass", cpp: "class Solution { public: int candy(vector<int>& ratings) { return 0; } };" }, function_name: "candy", examples: [] },
    { title: "Best Time to Buy and Sell Stock III", description: "You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete at most two transactions. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).", difficulty: "HARD", topics: ["Array", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int maxProfit(int[] prices) { return 0; } }", javascript: "var maxProfit = function(prices) {};", python: "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        pass", cpp: "class Solution { public: int maxProfit(vector<int>& prices) { return 0; } };" }, function_name: "maxProfit", examples: [] },
    { title: "Maximal Rectangle", description: "Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.", difficulty: "HARD", topics: ["Array", "Dynamic Programming", "Stack", "Matrix", "Monotonic Stack"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int maximalRectangle(char[][] matrix) { return 0; } }", javascript: "var maximalRectangle = function(matrix) {};", python: "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        pass", cpp: "class Solution { public: int maximalRectangle(vector<vector<char>>& matrix) { return 0; } };" }, function_name: "maximalRectangle", examples: [] },
    { title: "Interleaving String", description: "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2. An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that: s = s1 + s2 + ... + sn t = t1 + t2 + ... + tm |n - m| <= 1 The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Note: a + b is the concatenation of strings a and b.", difficulty: "MEDIUM", topics: ["String", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean isInterleave(String s1, String s2, String s3) { return false; } }", javascript: "var isInterleave = function(s1, s2, s3) {};", python: "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        pass", cpp: "class Solution { public: bool isInterleave(string s1, string s2, string s3) { return false; } };" }, function_name: "isInterleave", examples: [] },
    { title: "Word Ledger", description: "A transformation sequence from wordBegin to wordEnd using a dictionary wordList is a sequence of words wordBegin -> s1 -> s2 -> ... -> sk such that: Every adjacent pair of words differs by a single letter. Every si for 1 <= i <= k is in wordList. Note that wordBegin does not need to be in wordList. sk == wordEnd. Given two words, wordBegin and wordEnd, and a dictionary wordList, return the number of words in the shortest transformation sequence from wordBegin to wordEnd, or 0 if no such sequence exists.", difficulty: "HARD", topics: ["Hash Table", "String", "BFS"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int ladderLength(String beginWord, String endWord, List<String> wordList) { return 0; } }", javascript: "var ladderLength = function(beginWord, endWord, wordList) {};", python: "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        pass", cpp: "class Solution { public: int ladderLength(string beginWord, string endWord, vector<string>& wordList) { return 0; } };" }, function_name: "ladderLength", examples: [] },
    { title: "Minimum Window Substring", description: "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\". The testcases will be generated such that the answer is unique.", difficulty: "HARD", topics: ["Hash Table", "String", "Sliding Window"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public String minWindow(String s, String t) { return \"\"; } }", javascript: "var minWindow = function(s, t) {};", python: "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        pass", cpp: "class Solution { public: string minWindow(string s, string t) { return \"\"; } };" }, function_name: "minWindow", examples: [] },
    { title: "Text Justification", description: "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left-justified and no extra space is inserted between words.", difficulty: "HARD", topics: ["Array", "String", "Simulation"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<String> fullJustify(String[] words, int maxWidth) { return new ArrayList<>(); } }", javascript: "var fullJustify = function(words, maxWidth) {};", python: "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        pass", cpp: "class Solution { public: vector<string> fullJustify(vector<string>& words, int maxWidth) { return {}; } };" }, function_name: "fullJustify", examples: [] },
    { title: "Substring with Concatenation of All Words", description: "You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters. You can return the answer in any order.", difficulty: "HARD", topics: ["Hash Table", "String", "Sliding Window"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<Integer> findSubstring(String s, String[] words) { return new ArrayList<>(); } }", javascript: "var findSubstring = function(s, words) {};", python: "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        pass", cpp: "class Solution { public: vector<int> findSubstring(string s, vector<string>& words) { return {}; } };" }, function_name: "findSubstring", examples: [] },
    { title: "Reverse Nodes in k-Group", description: "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed.", difficulty: "HARD", topics: ["Linked List", "Recursion"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public ListNode reverseKGroup(ListNode head, int k) { return null; } }", javascript: "var reverseKGroup = function(head, k) {};", python: "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        pass", cpp: "class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { return nullptr; } };" }, function_name: "reverseKGroup", examples: [] },
    { title: "Merge k Sorted Lists", description: "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.", difficulty: "HARD", topics: ["Linked List", "Divide and Conquer", "Heap", "Merge Sort"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public ListNode mergeKLists(ListNode[] lists) { return null; } }", javascript: "var mergeKLists = function(lists) {};", python: "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        pass", cpp: "class Solution { public: ListNode* mergeKLists(vector<ListNode*>& lists) { return nullptr; } };" }, function_name: "mergeKLists", examples: [] },
    { title: "Median of Two Sorted Arrays", description: "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).", difficulty: "HARD", topics: ["Array", "Binary Search", "Divide and Conquer"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { return 0.0; } }", javascript: "var findMedianSortedArrays = function(nums1, nums2) {};", python: "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        pass", cpp: "class Solution { public: double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) { return 0.0; } };" }, function_name: "findMedianSortedArrays", examples: [] },
    { title: "Sum of Subarray Minimums", description: "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 10^9 + 7.", difficulty: "MEDIUM", topics: ["Array", "Dynamic Programming", "Stack", "Monotonic Stack"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int sumSubarrayMins(int[] arr) { return 0; } }", javascript: "var sumSubarrayMins = function(arr) {};", python: "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        pass", cpp: "class Solution { public: int sumSubarrayMins(vector<int>& arr) { return 0; } };" }, function_name: "sumSubarrayMins", examples: [] },
    { title: "Super Palindromes", description: "Let's say a positive integer is a super-palindrome if it is a palindrome, and it is also the square of a palindrome. Given two positive integers left and right represented as strings, return the number of super-palindromes integers in the inclusive range [left, right].", difficulty: "HARD", topics: ["Math", "Enumeration"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int superpalindromesInRange(String left, String right) { return 0; } }", javascript: "var superpalindromesInRange = function(left, right) {};", python: "class Solution:\n    def superpalindromesInRange(self, left: str, right: str) -> int:\n        pass", cpp: "class Solution { public: int superpalindromesInRange(string left, string right) { return 0; } };" }, function_name: "superpalindromesInRange", examples: [] },
    { title: "Find the Closest Palindrome", description: "Given a string n representing an integer, return the closest integer (not including itself), which is a palindrome. If there is a tie, return the smaller one. The closest is defined as the absolute difference minimized between two integers.", difficulty: "HARD", topics: ["Math", "String"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public String nearestPalindromic(String n) { return \"\"; } }", javascript: "var nearestPalindromic = function(n) {};", python: "class Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        pass", cpp: "class Solution { public: string nearestPalindromic(string n) { return \"\"; } };" }, function_name: "nearestPalindromic", examples: [] },
    { title: "Tag Validator", description: "Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all these hold: The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format: <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in all tags must be the same and contain only uppercase letters. For example, <DIV> and <DIV> are valid tags, but <DIV> and <div are not.", difficulty: "HARD", topics: ["String", "Stack"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean isValid(String code) { return false; } }", javascript: "var isValid = function(code) {};", python: "class Solution:\n    def isValid(self, code: str) -> bool:\n        pass", cpp: "class Solution { public: bool isValid(string code) { return false; } };" }, function_name: "isValid", examples: [] },
    { title: "Remove Comments", description: "Given a C++ program, remove comments from it. The program source is an array of strings source where source[i] is the ith line of the source code. This represents the result of splitting the original source code string by the newline character '\\n'. In C++, there are two types of comments: Line comments, which start with the two characters \"//\" and end at the end of the line. Block comments, which start with \"/*\" and end with \"*/\". If a line comment appears inside a block comment, it is ignored; usually, a block comment cannot appear inside a line comment.", difficulty: "MEDIUM", topics: ["Array", "String"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<String> removeComments(String[] source) { return new ArrayList<>(); } }", javascript: "var removeComments = function(source) {};", python: "class Solution:\n    def removeComments(self, source: List[str]) -> List[str]:\n        pass", cpp: "class Solution { public: vector<string> removeComments(vector<string>& source) { return {}; } };" }, function_name: "removeComments", examples: [] },
    { title: "Special Binary String", description: "Special binary strings are binary strings with the following two properties: The number of 0's is equal to the number of 1's. Every prefix of the binary string has at least as many 1's as 0's. Given a special binary string S, a move consists of choosing two consecutive, non-empty, special substrings of S, and swapping them. (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.) Return the lexicographically largest resulting string possible after any number of moves.", difficulty: "HARD", topics: ["String", "Recursion"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public String makeLargestSpecial(String s) { return \"\"; } }", javascript: "var makeLargestSpecial = function(s) {};", python: "class Solution:\n    def makeLargestSpecial(self, s: str) -> str:\n        pass", cpp: "class Solution { public: string makeLargestSpecial(string s) { return \"\"; } };" }, function_name: "makeLargestSpecial", examples: [] },
    { title: "Parse Lisp Expression", description: "You are given a string expression representing a Lisp-like expression to return the integer value of. The syntax for these expressions is: An expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always start with a \"(\", then a keyword or the operator, then one or more expressions separated by single spaces \" \", and finally end with a \")\". Let expression, Add expression, Mult expression are defined as follows: etc.", difficulty: "HARD", topics: ["Hash Table", "String", "Stack", "Recursion"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int evaluate(String expression) { return 0; } }", javascript: "var evaluate = function(expression) {};", python: "class Solution:\n    def evaluate(self, expression: str) -> int:\n        pass", cpp: "class Solution { public: int evaluate(string expression) { return 0; } };" }, function_name: "evaluate", examples: [] },
    { title: "My Calendar III", description: "A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is common to all k events.) You are given some events [start, end), after each given event, return the maximum k-booking between all the previous events.", difficulty: "HARD", topics: ["Segment Tree", "Ordered Set"], constraints: [], hints: [], boilerplate_code: { java: "class MyCalendarThree { public MyCalendarThree() {} public int book(int startTime, int endTime) { return 0; } }", javascript: "var MyCalendarThree = function() {}; MyCalendarThree.prototype.book = function(startTime, endTime) {};", python: "class MyCalendarThree:\n    def __init__(self):\n        pass\n    def book(self, startTime: int, endTime: int) -> int:\n        pass", cpp: "class MyCalendarThree { public: MyCalendarThree() {} int book(int startTime, int endTime) { return 0; } };" }, function_name: "book", examples: [] },
    { title: "Cherry Pickup", description: "You are given an n x n grid representing a field of cherries, each cell is one of the following: 0 means the cell is empty, so you can pass through, 1 means the cell contains a cherry, that you can pick up and pass through, or -1 means the cell contains a thorn that blocks your way. Return the maximum number of cherries you can collect following these rules: Starting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1). After reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells...", difficulty: "HARD", topics: ["Array", "Dynamic Programming", "Matrix"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int cherryPickup(int[][] grid) { return 0; } }", javascript: "var cherryPickup = function(grid) {};", python: "class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        pass", cpp: "class Solution { public: int cherryPickup(vector<vector<int>>& grid) { return 0; } };" }, function_name: "cherryPickup", examples: [] }
];
