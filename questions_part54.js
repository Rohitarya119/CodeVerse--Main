module.exports = [
    { title: "Pacific Atlantic Water Flow", description: "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges. Return a list of grid coordinates where water can flow to both the Pacific and Atlantic oceans.", difficulty: "MEDIUM", topics: ["Array", "DFS", "BFS", "Matrix"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<List<Integer>> pacificAtlantic(int[][] heights) { return new ArrayList<>(); } }", javascript: "var pacificAtlantic = function(heights) {};", python: "class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        pass", cpp: "class Solution { public: vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) { return {}; } };" }, function_name: "pacificAtlantic", examples: [] },
    { title: "Battleships in a Board", description: "Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.", difficulty: "MEDIUM", topics: ["Array", "DFS", "Matrix"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int countBattleships(char[][] board) { return 0; } }", javascript: "var countBattleships = function(board) {};", python: "class Solution:\n    def countBattleships(self, board: List[List[str]]) -> int:\n        pass", cpp: "class Solution { public: int countBattleships(vector<vector<char>>& board) { return 0; } };" }, function_name: "countBattleships", examples: [] },
    { title: "Find Right Interval", description: "You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique. The right interval for an interval i is an interval j such that startj >= endi and startj is minimized. Note that i may equal j. Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.", difficulty: "MEDIUM", topics: ["Array", "Binary Search", "Sorting"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int[] findRightInterval(int[][] intervals) { return new int[]{}; } }", javascript: "var findRightInterval = function(intervals) {};", python: "class Solution:\n    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\n        pass", cpp: "class Solution { public: vector<int> findRightInterval(vector<vector<int>>& intervals) { return {}; } };" }, function_name: "findRightInterval", examples: [] },
    { title: "Find All Anagrams in a String", description: "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.", difficulty: "MEDIUM", topics: ["Hash Table", "String", "Sliding Window"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<Integer> findAnagrams(String s, String p) { return new ArrayList<>(); } }", javascript: "var findAnagrams = function(s, p) {};", python: "class Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        pass", cpp: "class Solution { public: vector<int> findAnagrams(string s, string p) { return {}; } };" }, function_name: "findAnagrams", examples: [] },
    { title: "Find All Duplicates in an Array", description: "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.", difficulty: "MEDIUM", topics: ["Array", "Hash Table"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<Integer> findDuplicates(int[] nums) { return new ArrayList<>(); } }", javascript: "var findDuplicates = function(nums) {};", python: "class Solution:\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        pass", cpp: "class Solution { public: vector<int> findDuplicates(vector<int>& nums) { return {}; } };" }, function_name: "findDuplicates", examples: [] },
    { title: "String Compression", description: "Given an array of characters chars, compress it using the following algorithm: Begin with an empty string s. For each group of consecutive repeating characters in chars: If the group's length is 1, append the character to s. Otherwise, append the character followed by the group's length.", difficulty: "MEDIUM", topics: ["Two Pointers", "String"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int compress(char[] chars) { return 0; } }", javascript: "var compress = function(chars) {};", python: "class Solution:\n    def compress(self, chars: List[str]) -> int:\n        pass", cpp: "class Solution { public: int compress(vector<char>& chars) { return 0; } };" }, function_name: "compress", examples: [] },
    { title: "Add Two Numbers II", description: "You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.", difficulty: "MEDIUM", topics: ["Linked List", "Math", "Stack"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { return null; } }", javascript: "var addTwoNumbers = function(l1, l2) {};", python: "class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        pass", cpp: "class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { return nullptr; } };" }, function_name: "addTwoNumbers", examples: [] },
    { title: "Number of Boomerangs", description: "You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomerang is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Return the number of boomerangs.", difficulty: "MEDIUM", topics: ["Array", "Hash Table", "Math"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int numberOfBoomerangs(int[][] points) { return 0; } }", javascript: "var numberOfBoomerangs = function(points) {};", python: "class Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        pass", cpp: "class Solution { public: int numberOfBoomerangs(vector<vector<int>>& points) { return 0; } };" }, function_name: "numberOfBoomerangs", examples: [] },
    { title: "Serialize and Deserialize BST", description: "Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree.", difficulty: "MEDIUM", topics: ["String", "Tree", "DFS", "BFS", "Binary Search Tree"], constraints: [], hints: [], boilerplate_code: { java: "public class Codec { public String serialize(TreeNode root) { return \"\"; } public TreeNode deserialize(String data) { return null; } }", javascript: "var serialize = function(root) {}; var deserialize = function(data) {};", python: "class Codec:\n    def serialize(self, root: Optional[TreeNode]) -> str:\n        pass\n    def deserialize(self, data: str) -> Optional[TreeNode]:\n        pass", cpp: "class Codec { public: string serialize(TreeNode* root) { return \"\"; } TreeNode* deserialize(string data) { return nullptr; } };" }, function_name: "serialize", examples: [] },
    { title: "Delete Node in a BST", description: "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.", difficulty: "MEDIUM", topics: ["Tree", "Binary Search Tree"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public TreeNode deleteNode(TreeNode root, int key) { return null; } }", javascript: "var deleteNode = function(root, key) {};", python: "class Solution:\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n        pass", cpp: "class Solution { public: TreeNode* deleteNode(TreeNode* root, int key) { return nullptr; } };" }, function_name: "deleteNode", examples: [] },
    { title: "Frequency of the Most Frequent Element", description: "The frequency of an element is the number of times it occurs in an array. You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1. Return the maximum possible frequency of an element after performing at most k operations.", difficulty: "MEDIUM", topics: ["Array", "Binary Search", "Greedy", "Sliding Window", "Sorting", "Prefix Sum"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int maxFrequency(int[] nums, int k) { return 0; } }", javascript: "var maxFrequency = function(nums, k) {};", python: "class Solution:\n    def maxFrequency(self, nums: List[int], k: int) -> int:\n        pass", cpp: "class Solution { public: int maxFrequency(vector<int>& nums, int k) { return 0; } };" }, function_name: "maxFrequency", examples: [] },
    { title: "Minimum ASCII Delete Sum for Two Strings", description: "Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings equal.", difficulty: "MEDIUM", topics: ["String", "Dynamic Programming"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int minimumDeleteSum(String s1, String s2) { return 0; } }", javascript: "var minimumDeleteSum = function(s1, s2) {};", python: "class Solution:\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\n        pass", cpp: "class Solution { public: int minimumDeleteSum(string s1, string s2) { return 0; } };" }, function_name: "minimumDeleteSum", examples: [] },
    { title: "Subarray Product Less Than K", description: "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.", difficulty: "MEDIUM", topics: ["Array", "Sliding Window"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int numSubarrayProductLessThanK(int[] nums, int k) { return 0; } }", javascript: "var numSubarrayProductLessThanK = function(nums, k) {};", python: "class Solution:\n    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\n        pass", cpp: "class Solution { public: int numSubarrayProductLessThanK(vector<int>& nums, int k) { return 0; } };" }, function_name: "numSubarrayProductLessThanK", examples: [] },
    { title: "Random Pick with Weight", description: "You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index. You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).", difficulty: "MEDIUM", topics: ["Array", "Math", "Binary Search", "Prefix Sum", "Randomized"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public Solution(int[] w) {} public int pickIndex() { return 0; } }", javascript: "var Solution = function(w) {}; Solution.prototype.pickIndex = function() {};", python: "class Solution:\n    def __init__(self, w: List[int]):\n        pass\n    def pickIndex(self) -> int:\n        pass", cpp: "class Solution { public: Solution(vector<int>& w) {} int pickIndex() { return 0; } };" }, function_name: "pickIndex", examples: [] },
    { title: "Exam Room", description: "There is an exam room with n seats in a single row labeled from 0 to n - 1. When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. If no one is in the room, then the student sits at seat number 0.", difficulty: "MEDIUM", topics: ["Design", "Heap"], constraints: [], hints: [], boilerplate_code: { java: "class ExamRoom { public ExamRoom(int n) {} public int seat() { return 0; } public void leave(int p) {} }", javascript: "var ExamRoom = function(n) {}; ExamRoom.prototype.seat = function() {}; ExamRoom.prototype.leave = function(p) {};", python: "class ExamRoom:\n    def __init__(self, n: int):\n        pass\n    def seat(self) -> int:\n        pass\n    def leave(self, p: int) -> None:\n        pass", cpp: "class ExamRoom { public: ExamRoom(int n) {} int seat() { return 0; } void leave(int p) {} };" }, function_name: "seat", examples: [] },
    { title: "Score of Parentheses", description: "Given a balanced parentheses string s, return the score of the string. The score of a balanced parentheses string is based on the following rule: \"()\" has score 1. AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.", difficulty: "MEDIUM", topics: ["String", "Stack"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int scoreOfParentheses(String s) { return 0; } }", javascript: "var scoreOfParentheses = function(s) {};", python: "class Solution:\n    def scoreOfParentheses(self, s: str) -> int:\n        pass", cpp: "class Solution { public: int scoreOfParentheses(string s) { return 0; } };" }, function_name: "scoreOfParentheses", examples: [] },
    { title: "Mirror Reflection", description: "There is a special square room with mirrors on each of the four walls. Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2. The square room has walls of length p and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor. Given the two integers p and q, return the number of the receptor that the ray meets first.", difficulty: "MEDIUM", topics: ["Math", "Geometry"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int mirrorReflection(int p, int q) { return 0; } }", javascript: "var mirrorReflection = function(p, q) {};", python: "class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        pass", cpp: "class Solution { public: int mirrorReflection(int p, int q) { return 0; } };" }, function_name: "mirrorReflection", examples: [] },
    { title: "Buddy Strings", description: "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.", difficulty: "EASY", topics: ["Hash Table", "String"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean buddyStrings(String s, String goal) { return false; } }", javascript: "var buddyStrings = function(s, goal) {};", python: "class Solution:\n    def buddyStrings(self, s: str, goal: str) -> bool:\n        pass", cpp: "class Solution { public: bool buddyStrings(string s, string goal) { return false; } };" }, function_name: "buddyStrings", examples: [] },
    { title: "Lemonade Change", description: "At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time. Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5. Note that you do not have any change in hand at first. Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with correct change, or false otherwise.", difficulty: "EASY", topics: ["Array", "Greedy"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean lemonadeChange(int[] bills) { return false; } }", javascript: "var lemonadeChange = function(bills) {};", python: "class Solution:\n    def lemonadeChange(self, bills: List[int]) -> bool:\n        pass", cpp: "class Solution { public: bool lemonadeChange(vector<int>& bills) { return false; } };" }, function_name: "lemonadeChange", examples: [] },
    { title: "All Nodes Distance K in Binary Tree", description: "Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node. You can return the answer in any order.", difficulty: "MEDIUM", topics: ["Tree", "DFS", "BFS", "Binary Tree"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<Integer> distanceK(TreeNode root, TreeNode target, int k) { return new ArrayList<>(); } }", javascript: "var distanceK = function(root, target, k) {};", python: "class Solution:\n    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:\n        pass", cpp: "class Solution { public: vector<int> distanceK(TreeNode* root, TreeNode* target, int k) { return {}; } };" }, function_name: "distanceK", examples: [] },
    { title: "Smallest Subtree with all the Deepest Nodes", description: "Given the root of a binary tree, the depth of each node is the shortest distance to the root. Return the smallest subtree such that it contains all the deepest nodes in the original tree.", difficulty: "MEDIUM", topics: ["Tree", "DFS", "BFS", "Binary Tree"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public TreeNode subtreeWithAllDeepest(TreeNode root) { return null; } }", javascript: "var subtreeWithAllDeepest = function(root) {};", python: "class Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        pass", cpp: "class Solution { public: TreeNode* subtreeWithAllDeepest(TreeNode* root) { return nullptr; } };" }, function_name: "subtreeWithAllDeepest", examples: [] },
    { title: "Score After Flipping Matrix", description: "You are given an m x n binary matrix grid. A move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's). Every row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possible score after making any number of moves (including zero moves).", difficulty: "MEDIUM", topics: ["Array", "Greedy", "Bit Manipulation", "Matrix"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int matrixScore(int[][] grid) { return 0; } }", javascript: "var matrixScore = function(grid) {};", python: "class Solution:\n    def matrixScore(self, grid: List[List[int]]) -> int:\n        pass", cpp: "class Solution { public: int matrixScore(vector<vector<int>>& grid) { return 0; } };" }, function_name: "matrixScore", examples: [] },
    { title: "Advantage Shuffle", description: "You are given two integer arrays nums1 and nums2 of the same length. The advantage of nums1 with respect to nums2 is the number of indices i for which nums1[i] > nums2[i]. Return any permutation of nums1 that maximizes its advantage with respect to nums2.", difficulty: "MEDIUM", topics: ["Array", "Two Pointers", "Greedy", "Sorting"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int[] advantageCount(int[] nums1, int[] nums2) { return new int[]{}; } }", javascript: "var advantageCount = function(nums1, nums2) {};", python: "class Solution:\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        pass", cpp: "class Solution { public: vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) { return {}; } };" }, function_name: "advantageCount", examples: [] },
    { title: "Boats to Save People", description: "You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person.", difficulty: "MEDIUM", topics: ["Array", "Two Pointers", "Greedy", "Sorting"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int numRescueBoats(int[] people, int limit) { return 0; } }", javascript: "var numRescueBoats = function(people, limit) {};", python: "class Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\n        pass", cpp: "class Solution { public: int numRescueBoats(vector<int>& people, int limit) { return 0; } };" }, function_name: "numRescueBoats", examples: [] },
    { title: "Spiral Matrix III", description: "You start at the cell (rStart, cStart) of an rows x cols grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column. You will walk in a clockwise spiral shape to visit every position in this grid. Calculate the total number of steps to visit every position.", difficulty: "MEDIUM", topics: ["Array", "Matrix", "Simulation"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) { return new int[][]{}; } }", javascript: "var spiralMatrixIII = function(rows, cols, rStart, cStart) {};", python: "class Solution:\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\n        pass", cpp: "class Solution { public: vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) { return {}; } };" }, function_name: "spiralMatrixIII", examples: [] },
    { title: "Possible Bipartition", description: "We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Given the integer n and the array dislikes where dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the person labeled bi, return true if it is possible to split everyone into two groups in this way.", difficulty: "MEDIUM", topics: ["DFS", "BFS", "Union Find", "Graph"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public boolean possibleBipartition(int n, int[][] dislikes) { return false; } }", javascript: "var possibleBipartition = function(n, dislikes) {};", python: "class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        pass", cpp: "class Solution { public: bool possibleBipartition(int n, vector<vector<int>>& dislikes) { return false; } };" }, function_name: "possibleBipartition", examples: [] },
    { title: "Construct Binary Tree from Preorder and Postorder Traversal", description: "Given two integer arrays, preorder and postorder where preorder is the preorder traversal of a binary tree of distinct values and postorder is the postorder traversal of the same tree, reconstruct and return the binary tree.", difficulty: "MEDIUM", topics: ["Array", "HashTable", "Divide and Conquer", "Tree", "Binary Tree"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public TreeNode constructFromPrePost(int[] preorder, int[] postorder) { return null; } }", javascript: "var constructFromPrePost = function(preorder, postorder) {};", python: "class Solution:\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        pass", cpp: "class Solution { public: TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) { return nullptr; } };" }, function_name: "constructFromPrePost", examples: [] },
    { title: "Find and Replace Pattern", description: "Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.", difficulty: "MEDIUM", topics: ["Array", "Hash Table", "String"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public List<String> findAndReplacePattern(String[] words, String pattern) { return new ArrayList<>(); } }", javascript: "var findAndReplacePattern = function(words, pattern) {};", python: "class Solution:\n    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:\n        pass", cpp: "class Solution { public: vector<string> findAndReplacePattern(vector<string>& words, string pattern) { return {}; } };" }, function_name: "findAndReplacePattern", examples: [] },
    { title: "Fruit Into Baskets", description: "You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces. You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow: You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold. Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets. Once you reach a tree with fruit that cannot fit in your baskets, you must stop.", difficulty: "MEDIUM", topics: ["Array", "Hash Table", "Sliding Window"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int totalFruit(int[] fruits) { return 0; } }", javascript: "var totalFruit = function(fruits) {};", python: "class Solution:\n    def totalFruit(self, fruits: List[int]) -> int:\n        pass", cpp: "class Solution { public: int totalFruit(vector<int>& fruits) { return 0; } };" }, function_name: "totalFruit", examples: [] },
    { title: "Snakes and Ladders", description: "You are given an n x n integer matrix board where the cells are labeled from 1 to n^2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row. You start on square 1 of the board. In each move, starting from square curr, do the following: Choose a destination square next with a label in the range [curr + 1, min(curr + 6, n^2)]. If next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next. Return the least number of moves required to reach the square n^2. If it is not possible to reach the square, return -1.", difficulty: "MEDIUM", topics: ["Array", "BFS", "Matrix"], constraints: [], hints: [], boilerplate_code: { java: "class Solution { public int snakesAndLadders(int[][] board) { return 0; } }", javascript: "var snakesAndLadders = function(board) {};", python: "class Solution:\n    def snakesAndLadders(self, board: List[List[int]]) -> int:\n        pass", cpp: "class Solution { public: int snakesAndLadders(vector<vector<int>>& board) { return 0; } };" }, function_name: "snakesAndLadders", examples: [] }
];
